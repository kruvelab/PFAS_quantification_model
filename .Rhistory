union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
connections
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
View(names_of_atoms)
library(fingerprint)
library(rcdk)
library(fingerprint)
sp <- get.smiles.parser()
smiles <- c('CCC', 'CCN', 'CCN(C)(C)', 'c1ccccc1Cc1ccccc1','C1CCC1CC(CN(C)(C))CC(=O)CC')
mols <- parse.smiles(smiles)
fp <- get.fingerprint(mols[[1]])
fps <- lapply(mols, get.fingerprint, type='maccs')
fp.to.matrix(fp)
fp.to.matrix(fps)
as.data.frame(fp.to.matrix(fps))
## get Substructure count fingerprint for user defined fragments
mol1 <- parse.smiles("c1ccccc1CCC")[[1]]
smarts <- c("c1ccccc1", "[CX4H3][#6]", "[CX2]#[CX2]")
fps <- get.fingerprint(mol1, type='substructure', fp.mode='count',
substructure.pattern=smarts)
as.data.frame(fp.to.matrix(fps))
fps
setwd("C:/Users/annel/Nextcloud/mudeli script ja failid/PFOA_semi_quant/PFOA_semi_quant")
setwd("C:/Users/annel/Nextcloud/mudeli script ja failid/PFOA_semi_quant/PFOA_semi_quant")
library(tidyverse)
library(plotly)
#setwd("~/GitHub/PFOA_semi_quant")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
setwd("C:/Users/annel/Nextcloud/mudeli script ja failid/PFOA_semi_quant/PFOA_semi_quant")
regressor = readRDS("regressors/regressor_neg.rds")
descs_names = readRDS("regressors/negative_descs.rds")
filename = "data/Batch 1 Semi Quant.xlsx"
Orbitrap_dataset_raw = read_excel_allsheets(filename)
Orbitrap_dataset_raw = Orbitrap_dataset_raw %>%
na.omit(Area) %>%
filter(Area != "N/F") %>%
mutate(Area = as.numeric(Area))
SMILES_data = read_delim("data/Smiles_for_Target_PFAS.csv",
delim = ",",
col_names = TRUE)
SMILES_data = SMILES_data %>%
rename(Compound = ID) %>%
select(Compound, SMILES) %>%
na.omit()
descs_calc_PFOA = read_delim("data/descs_calc.csv",
delim = ",",
col_names = TRUE)
descs_calc_PFOA = descs_calc_PFOA %>%
select(Compound, SMILES, all_of(descs_names))
descs_calc_PFOA = descs_calc_PFOA %>%
group_by(SMILES) %>%
mutate(IC = isotopedistribution(SMILES),
MW = molecularmass(SMILES))
#eluent---
eluent = read_delim("data/eluent.csv",
delim = ",",
col_names = TRUE)
organic_modifier = "MeCN"
pH.aq. = 7.0
data = Orbitrap_dataset_raw %>%
left_join(descs_calc_PFOA)
data = data %>%
mutate(
RT = as.numeric(RT),
area_IC = Area*IC,
organic_modifier = organic_modifier,
pH.aq. = pH.aq.,
NH4 = 1, #1 if th ebuffer contains NH¤ ions , 0 if not.
organic = organicpercentage(eluent,RT),
viscosity = viscosity(organic,organic_modifier),
surface_tension = surfacetension(organic,organic_modifier),
polarity_index = polarityindex(organic,organic_modifier))
#?? why are there some missing smiles- Anneli
training = data %>%
filter(!is.na(SMILES)) %>%
filter(`Theoretical Amt` != "N/F") %>%
filter(`Theoretical Amt` != "N/A") %>%
mutate(`Theoretical Amt` = as.numeric(`Theoretical Amt`)) %>%
mutate(`Theoretical Amt` = `Theoretical Amt`/MW) #correct with MW
training = training %>%
group_by(SMILES) %>%
mutate(slope = linear_regression(area_IC, `Theoretical Amt`)$slope) %>%
ungroup()
IE_pred = training %>%
mutate(logIE_pred = 0) %>%
na.omit()
regressor = readRDS("regressors/regressor_neg_new.rds")
IE_pred = training %>%
mutate(logIE_pred = 0) %>%
na.omit()
prediction =  predict(regressor, newdata = IE_pred, predict.all = TRUE)
prediction = prediction$aggregate
IE_pred <- IE_pred %>%
mutate(logIE_pred = prediction) %>%
select(SMILES,logIE_pred, everything())
IE_pred = IE_pred %>%
select(Compound, SMILES, logIE_pred, slope, everything())
IE_slope_cor = ggplot(data = IE_pred) +
geom_point(mapping = aes(x = logIE_pred,
y = slope,
text = Compound)) +
scale_y_log10()
graph_1sttryPFAScal=ggplotly(IE_slope_cor)
IE_slope_cor
descs_calc_PFOA = read_delim("data/descs_calc.csv",
delim = ",",
col_names = TRUE)
library(tidyverse)
library(plotly)
#setwd("~/GitHub/PFOA_semi_quant")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
setwd("C:/Users/annel/Nextcloud/mudeli script ja failid/PFOA_semi_quant/PFOA_semi_quant")
#regressor----
regressor = readRDS("regressors/regressor_neg_new.rds")
descs_names = readRDS("regressors/negative_descs.rds")
#lcms data ----
filename = "data/Batch 1 Semi Quant.xlsx"
Orbitrap_dataset_raw = read_excel_allsheets(filename)
Orbitrap_dataset_raw = Orbitrap_dataset_raw %>%
na.omit(Area) %>%
filter(Area != "N/F") %>%
mutate(Area = as.numeric(Area))
#smiles and descriptors----
SMILES_data = read_delim("data/Smiles_for_Target_PFAS.csv",
delim = ",",
col_names = TRUE)
SMILES_data = SMILES_data %>%
rename(Compound = ID) %>%
select(Compound, SMILES) %>%
na.omit()
#descs_calc_PFOA = PaDEL_original(SMILES_data)
descs_calc_PFOA = read_delim("data/descs_calc.csv",
delim = ",",
col_names = TRUE)
descs_calc_PFOA = descs_calc_PFOA %>%
select(Compound, SMILES,
#all_of(descs_names),
everything())
descs_calc_PFOA = descs_calc_PFOA %>%
group_by(SMILES) %>%
mutate(IC = isotopedistribution(SMILES),
MW = molecularmass(SMILES))
#eluent---
eluent = read_delim("data/eluent.csv",
delim = ",",
col_names = TRUE)
organic_modifier = "MeCN"
pH.aq. = 7.0
data = Orbitrap_dataset_raw %>%
left_join(descs_calc_PFOA)
data = data %>%
mutate(
RT = as.numeric(RT),
area_IC = Area*IC,
organic_modifier = organic_modifier,
pH.aq. = pH.aq.,
NH4 = 1, #1 if th ebuffer contains NH¤ ions , 0 if not.
organic = organicpercentage(eluent,RT),
viscosity = viscosity(organic,organic_modifier),
surface_tension = surfacetension(organic,organic_modifier),
polarity_index = polarityindex(organic,organic_modifier))
#?? why are there some missing smiles- Anneli
training = data %>%
filter(!is.na(SMILES)) %>%
filter(`Theoretical Amt` != "N/F") %>%
filter(`Theoretical Amt` != "N/A") %>%
mutate(`Theoretical Amt` = as.numeric(`Theoretical Amt`)) %>%
mutate(`Theoretical Amt` = `Theoretical Amt`/MW) #correct with MW
ggplot(data = training) +
geom_point(mapping = aes(x = `Theoretical Amt`,
y = area_IC)) +
facet_wrap(~Compound)
ggplot(data = training) +
geom_point(mapping = aes(x = `Theoretical Amt`,
y = area_IC)) +
facet_wrap(~Compound, scales = "free")
training = training %>%
group_by(SMILES) %>%
mutate(slope = linear_regression(area_IC, `Theoretical Amt`)$slope) %>%
ungroup()
IE_pred = training %>%
mutate(logIE_pred = 0) %>%
na.omit()
prediction =  predict(regressor, newdata = IE_pred, predict.all = TRUE)
prediction = prediction$aggregate
IE_pred <- IE_pred %>%
mutate(logIE_pred = prediction) %>%
select(SMILES,logIE_pred, everything())
IE_pred = IE_pred %>%
select(Compound, SMILES, logIE_pred, slope, everything())
IE_slope_cor = ggplot(data = IE_pred) +
geom_point(mapping = aes(x = logIE_pred,
y = slope,
text = Compound)) +
scale_y_log10()
IE_slope_cor
graph_1sttryPFAScal=ggplotly(IE_slope_cor)
graph_1sttryPFAScal
slope_RT_cor = ggplot(data = IE_pred) +
geom_point(mapping = aes(x = as.numeric(RT),
y = slope,
text = Compound)) +
scale_y_log10()
ggplotly(slope_RT_cor)
<<<<<<< Updated upstream
View(IE_pred)
ggplot(data = IE_pred) +
geom_point(mapping = aes(x = AlogP,
y = slope,
text = Compound)) +
scale_y_log10()
ggplot(data = IE_pred) +
geom_point(mapping = aes(x = ALogP,
y = slope,
text = Compound))
graph_slope_logP = ggplot(data = IE_pred) +
geom_point(mapping = aes(x = ALogP,
y = slope,
text = Compound))
ggplotly(graph_slope_logP)
=======
ggplotly(IE_slope_cor)
View(data)
library(tidyverse)
library(plotly)
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
source('~/GitHub/PFOA_semi_quant/IE_calc_211102.R')
setwd("~/GitHub/PFOA_semi_quant")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("rjson")
install.packages("janitor")
install.packages("car")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("caret")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("caTools")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("enviPat")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("gbm")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("gsubfn")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("Metrics")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("randomForest")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("rcdk")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("rJava")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_281')
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("RRF")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
install.packages("OrgMassSpecR")
source("code/PaDEL_descs_calculator.R")
source("code/reading_excel.R")
source("code/compound_eluent.R")
regressor = readRDS("regressors/regressor_neg.rds")
View(regressor)
descs_names = readRDS("regressors/negative_descs.rds")
filename = "data/Batch 1 Semi Quant.xlsx"
Orbitrap_dataset_raw = read_excel_allsheets(filename)
View(read_excel_allsheets)
Orbitrap_dataset_raw = Orbitrap_dataset_raw %>%
na.omit(Area) %>%
filter(Area != "N/F") %>%
mutate(Area = as.numeric(Area))
View(Orbitrap_dataset_raw)
SMILES_data = read_delim("data/Smiles_for_Target_PFAS.csv",
delim = ",",
col_names = TRUE)
View(SMILES_data)
SMILES_data = SMILES_data %>%
rename(Compound = ID) %>%
select(Compound, SMILES) %>%
na.omit()
View(Orbitrap_dataset_raw)
View(SMILES_data)
descs_calc_PFOA = PaDEL_original(SMILES_data)
View(PaDEL_original)
command = "java -jar PaDEL-Descriptor/PaDEL-Descriptor.jar -dir" #file name where they will be calculated
command_final = paste(command, "SMILES.smi", "-file", "descs_calc.csv", "-2d", sep =" ") #makes text for command prompt
javaOutput = system(command_final, intern = TRUE) #goes into commant prompt
system(command_final, intern = TRUE)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_281')
system(command_final, intern = TRUE)
rJava::head()
descs_calc_PFOA = read_delim("descs_calc.csv",
delim = ",",
col_names = TRUE)
descs_calc_PFOA = read_delim("descs_calc.csv",
delim = ",",
col_names = TRUE)
View(descs_calc_PFOA)
View(SMILES_data)
descs_calc_PFOA = descs_calc_PFOA %>%
select(Compound, SMILES, all_of(descs_names))
descs_calc_PFOA = descs_calc_PFOA %>%
group_by(SMILES) %>%
mutate(IC = isotopedistribution(SMILES),
MW = molecularmass(SMILES))
View(descs_calc_PFOA)
descs_calc_PFOA = read_delim("data/descs_calc.csv",
delim = ",",
col_names = TRUE)
descs_calc_PFOA = descs_calc_PFOA %>%
select(Compound, SMILES, all_of(descs_names))
descs_calc_PFOA = descs_calc_PFOA %>%
group_by(SMILES) %>%
mutate(IC = isotopedistribution(SMILES),
MW = molecularmass(SMILES))
View(isotopes)
View(Orbitrap_dataset_raw)
View(descs_calc_PFOA)
#eluent---
eluent = read_delim("data/eluent.csv",
delim = ",",
col_names = TRUE)
View(eluent)
organic_modifier = "MeCN"
organic_modifier = "MeCN"
pH.aq. = 7.0
data = Orbitrap_dataset_raw %>%
left_join(descs_calc_PFOA)
data = data %>%
mutate(
RT = as.numeric(RT),
area_IC = Area*IC,
organic_modifier = organic_modifier,
pH.aq. = pH.aq.,
NH4 = 1, #1 if th ebuffer contains NH¤ ions , 0 if not.
organic = organicpercentage(eluent,RT),
viscosity = viscosity(organic,organic_modifier),
surface_tension = surfacetension(organic,organic_modifier),
polarity_index = polarityindex(organic,organic_modifier))
View(descs_calc_PFOA)
View(SMILES_data)
View(descs_calc_PFOA)
View(data)
#?? why are there some missing smiles- Anneli
training = data %>%
filter(!is.na(SMILES)) %>%
filter(`Theoretical Amt` != "N/F") %>%
filter(`Theoretical Amt` != "N/A") %>%
mutate(`Theoretical Amt` = as.numeric(`Theoretical Amt`)) %>%
mutate(`Theoretical Amt` = `Theoretical Amt`/MW) #correct with MW
training = training %>%
group_by(SMILES) %>%
mutate(slope = linear_regression(area_IC, `Theoretical Amt`)$slope) %>%
ungroup()
IE_pred = training %>%
mutate(logIE_pred = 0) %>%
na.omit()
prediction =  predict(regressor, newdata = IE_pred, predict.all = TRUE)
prediction = prediction$aggregate
IE_pred <- IE_pred %>%
mutate(logIE_pred = prediction) %>%
select(SMILES,logIE_pred, everything())
View(IE_pred)
IE_pred = IE_pred %>%
select(Compound, SMILES, logIE_pred, slope, everything())
View(IE_pred)
IE_slope_cor = ggplot(data = IE_pred) +
geom_point(mapping = aes(x = logIE_pred,
y = slope,
text = Compound)) +
scale_y_log10()
IE_slope_cor
ggplotly(IE_slope_cor)
graph_1sttryPFAScal=ggplotly(IE_slope_cor)
install.packages("htmlwidgets")
install.packages("htmlwidgets")
install.packages("htmlwidgets")
install.packages("htmlwidgets")
htmlwidgets::saveWidget(as_widget(graph_1sttryPFAScal), "1stryPFAScal.html")
htmlwidgets::saveWidget(plotly::as_widget(graph_1sttryPFAScal), "1stryPFAScal.html")
>>>>>>> Stashed changes
